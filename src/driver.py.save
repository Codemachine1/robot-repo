#!/usr/bin/env python
from rrb3 import *
import RPi.GPIO as GPIO
import threading
import math
#import tf
import time
import rospy
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import Twist
rospy.init_node('driver', anonymous=True)
leftTicks=0
rightTicks=0
previoustime=0
GPIO.setmode(GPIO.BCM)
GPIO.setup(19,GPIO.IN)
GPIO.setup(16,GPIO.IN)
wheelRadius=0
rr = RRB3(9, 6)
scan_frequency=.3
encoderDistance=0.000875
ROBOT_WIDTH=.237

def leftcallback(channel):
        global leftTicks
        leftTicks+=1 
def rightcallback(channel):
        global rightTicks
        rightTicks+=1

GPIO.add_event_detect(19, GPIO.FALLING, callback=leftcallback, bouncetime=1)
GPIO.add_event_detect(16, GPIO.FALLING, callback=rightcallback, bouncetime=1)

def get_ping_distance(pinNumber):
        endtime=0
        starttime=0
        GPIO.setup(pinNumber, GPIO.OUT)
        GPIO.output(pinNumber, 0)

        time.sleep(0.000002)

        #send trigger signal  
        GPIO.output(pinNumber, 1)

        time.sleep(0.000005)

        GPIO.output(pinNumber, 0)

        GPIO.setup(pinNumber, GPIO.IN)

        while GPIO.input(pinNumber)==0:

                starttime=time.time()

        while GPIO.input(pinNumber)==1:
                endtime=time.time()

        duration=endtime-starttime
        # Distance is defined as time/2 (there and back) * speed of sound 34000 cm/s   
        distance=duration*34000/2
        return distance

def callback(data):
    rightMotorSpeed=0
    leftMotorSpeed=0
    leftmotordirection=0

    leftMotorSpeed=data.linear.x-data.angular.z*ROBOT_WIDTH/2
    rightMotorSpeed= data.linear.x + data.angular.z*ROBOT_WIDTH/2
    if leftMotorSpeed<0:
        leftmotordirection=0
    else:
        leftmotordirection=1
    if rightMotorSpeed<0:
        rightmotordirection=0
    else:
        rightmotordirection=1

    print("rightspeed:"+str(rightMotorSpeed)+"leftspeed:"+str(leftMotorSpeed))
    rr.set_motors(abs(leftMotorSpeed),leftmotordirection,abs(rightMotorSpeed),rightmotordirection)
def publishscans():
	scan_publisher=rospy.Publisher('/laser_scan',LaserScan)
	scans=[]
	for sensor in [26,20,21]:
		scans.append(get_ping_distance(sensor))
	msg=LaserScan()
	msg.header.stamp=rospy.Time.now()
	msg.header.frame_id="laser_frame"
	msg.angle_min=-.79
	msg.angle_max=.79
	msg.angle_increment=.79
	msg.ranges=scans
	msg.time_increment=(1/scan_frequency)/3
	msg.range_min=.4
	msg.range_max=2
	scan_publisher.publish(msg)




def publishOdometry(position,velocity,heading):
    odom_publish=rospy.Publisher('/odom',Odometry)
#    tfbroadcaster=tf.TransformBroadcaster()
    msg = Odometry()
    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = '/odom'
    msg.child_frame_id =  '/base_footprint'
    msg.pose.pose.position.x=position[0]
    msg.pose.pose.position.y=position[1]
    msg.pose.pose.position.z=0
    msg.twist.twist.linear.x=velocity[0]
    msg.twist.twist.linear.y=0
    msg.twist.twist.linear.z=0
    msg.twist.twist.angular.x=0
    msg.twist.twist.angular.y=0
    msg.twist.twist.angular.z=velocity[1]
    msg.pose.pose.orientation=Quaternion(heading,0,0,1)
    odom_publish.publish(msg)
 #   tfbroadcaster.sendTransform((x,y,0),(heading,0,0,1),msg.header.stamp,msg.header.frame_id,msg.child_frame_id)

x=0
y=0
heading=0
while not rospy.is_shutdown():
    ds=((encoderDistance*leftTicks)+(rightTicks*encoderDistance))/2
    dth=((encoderDistance*leftTicks)-(encoderDistance*rightTicks))/.237
    dx=ds*math.cos(heading+dth/2)
    dy=ds*math.sin(heading+dth/2)
    x+=dx
    y+=dy
    heading+=dth
    distance=math.sqrt(dx**2+dy**2)
    newtime=time.clock()
    deltatime=newtime-previoustime
    publishOdometry([x,y],[(distance/deltatime),(dth/deltatime)],heading)
    previoustime=newtime
    publishscans()
    rospy.Subscriber("cmd_vel",Twist,callback)


